\documentclass[]{ceurart}

\usepackage{soul}
\usepackage[dvipsnames]{xcolor}
\usepackage{caption}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{array}
\usepackage{multirow}
\usepackage[noend]
   {algorithm2e}
\usepackage{amsmath}


\SetNlSty{bfseries}{\color{black}}{}

\lstset{breaklines=true}

\newcommand\ty[1]{\textsf{#1}}
\newcommand\sym[1]{\textsf{#1}}
\newcommand\var[1]{\mathit{#1}}

%% TYPESETTING: hacks
\newcommand\medrightarrow{\mathrel{{{\color{black}\relbar}\kern-0.9ex\rlap{\color{white}\ensuremath{\blacksquare}}\kern-0.9ex}\joinrel{\color{black}\rightarrow}}}
\newcommand\medleftarrow{\mathrel{{\color{black}\leftarrow}\kern-0.9ex\rlap{\color{white}\ensuremath{\blacksquare}}\kern-0.9ex\joinrel{{\color{black}\relbar}}}}
\newcommand\medleftrightarrow{\mathrel{\leftarrow\kern-1.685ex\rightarrow}}
\newcommand\Medrightarrow{\mathrel{{{\color{black}\Relbar}\kern-0.9ex\rlap{\color{white}\ensuremath{\blacksquare}}\kern-0.9ex}\joinrel{\color{black}\Rightarrow}}}
\newcommand\Medleftrightarrow{\mathrel{\Leftarrow\kern-1.685ex\Rightarrow}}



\newdefinition{definition}{Definition}
\newdefinition{example}[definition]{Example}


% algo2e package
\SetFuncSty{textit}
\SetFuncArgSty{text}
\SetArgSty{text}
\SetDataSty{text}

\DontPrintSemicolon

\SetKwProg{Fn}{Function}{}{end}\SetKwFunction{FRecurs}{FnRecursive}%
\newcommand{\forcond}{$i=0$ \KwTo $n$}

\definecolor{ourblueviolet}{HTML}{0071BC}
\definecolor{grey}{rgb}{0.8,0.8,0.8}
\definecolor{algoColorKeyword}{named}{grey}
\makeatletter
% Block with a vertical line
\renewcommand{\algocf@Vsline}[1]{%
   \strut\par\nointerlineskip%
   \algocf@bblockcode%
   \algocf@push{\skiprule}%
   \hbox{{\color{algoColorKeyword}\vrule}%
      \vtop{\algocf@push{\skiptext}%
      \vtop{\algocf@addskiptotal\advance\hsize by -\skiplength #1}}%
   }%
   \algocf@pop{\skiprule}%
   \algocf@bblockcode%
}
\makeatother

\begin{document}

\copyrightyear{2024}
\copyrightclause{Copyright for this paper by its authors. Use permitted under Creative Commons License Attribution 4.0 International (CC BY 4.0)}

\conference{Submitted draft} % TODO update

% TODO, at the end check the following
%   - formulas -> formulae
%   - clause -> formula
%   - monomorphization -> monomorphisation
%   - higher-order -> higher order
%   - TH1 with ugly 1
%   - correctly spelled TPTP, Leo-III, Zipperposition, E, Vampire
%   - use of formula vs clause
%   - polymorphic and monomorphic
%   - title of bits of the algorithms
%   - TH1 ugly for height of 1 reasons, can be fixed with case feature
%   - eg or ex -> e.g.
%   - function symbol -> symbol instance (depends on context)
%   - ... -> \dots
%   - comma splices!!!!
%   - add \; at the end of each algorithm line
%   - ``'' -> `'
%   - use \Phi instead of F for formulae
%   - concrete types -> monomorphic types
%   - use in not \in when we are not precisely dealing with set membership
%   - $\Phi$ for problem and $\varphi_1$ etc.
%   - n-uples -> n-tuples
%   - ize -> ise (in cas i forgot any)
%   - remove vertical space before lists (if allowed)
%   - add full stops to end of sentences in itemize
%   - B\"ome -> B\"ohme

\title{Iterative Monomorphisation}

\author[1,2]{Tanguy Bozec}[%
email=tanguy.bozec@ens-paris-saclay.fr,
]
\author[2]{Jasmin Blanchette}[%
email=jasmin.blanchette@ifi.lmu.de,
%url=https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html,
]
\address[1]{ENS Paris-Saclay, Université Paris-Saclay, France}
\address[2]{Institute of Informatics, Ludwig-Maximilians-Universität München, Germany}


\begin{abstract}
Monomorphisation can be used to extend monomorphic provers to support polymorphic logics. We propose an iterative approach, which is necessarily incomplete but which works well in practice. It is implemented in the Zipperposition prover, where it can be used to translate away polymorphism before invoking the monomorphic prover E as a backend. Our evaluation demonstrates that this approach increases Zipperposition's success rate. Moreover, we find iterative monomorphisation to be competitive with native implementations of polymorphism.
\end{abstract}

\begin{keywords}
   Polymorphism\sep
   monomorphism\sep
   automatic theorem proving
\end{keywords}

\maketitle

% target page number: 2-2.5
\section{Introduction}

One of the main applications of automatic theorem provers is to provide automation to users of proof assistants. Many proof assistants, such as HOL4 \cite{slind-norrish-2008}, HOL Light \cite{harrison-2009}, and
Isabelle/HOL \cite{nipkow-et-al-2002}, support rank-1 polymorphism, where type quantification is allowed only at the top level of formulae. On the other hand, many automatic provers operate only on monomorphic logics. One approach to close this gap is to extend provers to natively support polymorphism, as has been done for Vampire \cite{bhayat-reger-2020}. This, however, entails a lot of work that needs to be redone for every prover.

The alternative is to translate polymorphic problems to monomorphic problems. One approach is to encode polymorphism using dedicated function or predicate symbols \cite{mono-trans} in a monomorphic logic. Another approach is to encode polymorphism using {iterative monomorphisation}, as introduced by B\"ohme \cite[Section 2.2.1]{sb-phd}. This method relies on heuristically instantiating the formulae's type variables with concrete types.

By a type version of the compactness theorem, we have that in first order logic, given a polymorphic formula \(\varphi\), there exist an equisatisfiable finite set of monomorphic instances of \(\varphi\). However, such a set cannot be computed \cite[Theorem 1]{expr-poly-types}. As a result, any monomorphisation method based on instantiation of type variables is
bound to be incomplete.

B\"ohme's iterative approach is implemented as part of the SMT (satisfiability modulo theories) integration \cite[Chapter 2]{sb-phd} in Isabelle/HOL. This implementation is also used by Sledgehammer \cite{judgement, hammer} to interface with superposition based automatic theorem provers. However, it is is documented only as a single subsection in his PhD thesis \cite[Section 2.2.1]{sb-phd}.

In this paper, we present an algorithm based on our understanding of his description and implementation (Section~\ref{sec:high level-algorithm}). We also provide a more detailed description to help future implementers. In addition, this description shows some of the ways in which an implementation can be made more efficient and avoid explosions (Section~\ref{sec:low-level-algorithm}).

The algorithm works as follows. We assume problems to be sets of formulae. All symbols of the problem are collected, and the polymorphic instances of symbols are matched against the monomorphic ones. This yields new instances of symbols, both polymorphic and monomorphic. The process is then iterated
a number of times, making use of the newly generated instances.

Consider the unary type constructor \ty{list}. If a formula contains $\ty{list}(\alpha)$, where $\alpha$ is a type variable, it may be possible to generate the types $\ty{list}(\ty{int})$, $\ty{list}(\ty{list}(\ty{int}))$, etc. However, because new types emerge through matching, $\ty{list}(\ty{list}(\ty{int}))$ can be obtained only once the $\ty{list}(\ty{int})$ instance has already been generated. This example also makes it clear that the set of instances that can be generated is infinite.

To keep the number of generated formulae finite, we limit the number of iterations. After the iterations are completed, the new monomorphic symbol instances are used to instantiate the polymorphic symbols in the problem's formulae, generating new monomorphic formulae. Finally, because monomorphic provers generally do not support $n$-ary type constructors, types must be `mangled'; for example, the compound type $\ty{list}(\ty{int})$ could be mangled to the constant $\ty{list\_int}$.

We implemented iterative monormorphisation in Zipperpostion \cite{zipp}, a higher order prover written in OCaml. Although Zipperposition is polymorphic, it uses the monomorphic prover E \cite{e} as a backend. This means that E can now be used with polymorphic problems. Moreover, our implementation of the algorithm in Zipperposition can be used as a preprocessor to interface with other stand-alone provers.

Our empirical evaluation on TPTP \cite{tptp} problems attempts to answer three questions (Section~\ref{sec:evaluation}):
\begin{enumerate}
\item Is the new Zipperposition with the E backend more successful on polymorphic problems than Zipperposition without backend?

\item How competitive are monomorphic provers on monomorphised polymorphic problems?

\item Is iterative monomorphisation more effective than the native polymorphism implemented in polymorphic provers?
\end{enumerate}

Our findings are as follows:
\begin{enumerate}
\item Zipperposition benefits substantially from the E backend.

\item E with monomorphisation comes close second to the polymorphic prover Vampire.

\item For Leo-III \cite{leo-iii} and Vampire \cite{vamp}, we find that monomorphisation is indeed more effective than native polymorphism.
\end{enumerate}

% target page number: 0.5-1.5
\section{Preliminaries}
\label{sec:preliminaries}

This algorithm works independently of the structure of the problem's formulae. It relies exclusively on the formulae's monomorphic and polymorphic symbol instances. Type variables are assumed to be implicitly universally quantified at a formula's top level. The precise form of formulae is left unspecified.
Due to this generality, iterative monomorphisation can be used with any reasonable rank-1 polymorphic logic. In particular, it can operate in the polymorphic first and higher order logics embodied by TPTP's TF1 and TH1 syntaxes \cite{blanchette-paskevich-2013,th1}, implemented by several automatic provers.


Our abstract framework relies on the following basic definitions.

\begin{definition}
A (\emph{polymorphic}) \emph{type} \(\tau\) can be a type variable (e.g.\ \(\alpha\)) or
the application of an \(n\)-ary type constructor to \(n\) types (e.g.\ \(\ty{list}(\alpha)\), \(\ty{map}(\ty{int},\ty{string})\)).
If $n = 0$, we omit the parentheses (e.g.\ \(\ty{int}\)).
\end{definition}

\begin{definition}
A type is \emph{monomorphic} if it contains no type variables.
\end{definition}

\begin{definition}
A (function or predicate) {symbol} \(f\) has a \emph{type arity} that defines the number of type arguments it takes. A \emph{symbol instance} is a symbol applied to type arguments listed between angle brackets: \(f\langle \tau_1, \dots, \tau_n\rangle\), where each $\tau_i$ is a type. If $n = 0$, we omit the brackets (e.g.\ $f$).
\end{definition}

\begin{definition}
A (\emph{type}) \emph{substitution} is a partial function mapping a finite number of type variables to corresponding types. Substitutions are written as
$\sigma = \{\alpha_1\mapsto\tau_1, \dots, \alpha_n\mapsto\tau_n\}$. They are assumed to be lifted to formulae; thus, $\sigma(\varphi)$ yields the variant of $\varphi$ in which each $\alpha_i$ is replaced by $\tau_i$.
Given two substitutions \(\tau, \upsilon\), the successive application of \(\tau\) and \(\upsilon\) is denoted by \(\upsilon \circ \tau\).
\end{definition}

\begin{definition}
Two substitutions \(\{\alpha_1 \mapsto \tau_1, \dots, \alpha_m\mapsto\tau_m\}\) and \(\{\beta_1 \mapsto \upsilon_1, \dots, \beta_n\mapsto\upsilon_n\}\) are \emph{compatible} if \(\alpha_i = \beta_j\) implies \(\tau_i = \upsilon_j\) for all \(i, j\).
\end{definition}


\begin{definition}
Given two types \(\tau, \upsilon\), \emph{matching} \(\upsilon\) against \(\tau\) will either fail or yield a substitution \(\sigma\) such that \(\sigma(\upsilon) = \tau\).
\end{definition}

In the following sections, we will always match a polymorphic type $\upsilon$ against a monomorphic type $\tau$.

% target page number: 2-4
\section{High level algorithm}
\label{sec:high level-algorithm}

The iterative monomorphisation algorithm takes a polymorphic problem as input and returns a monomorphic problem. It operates by applying an arbitrary number of iterations. Each iteration takes a polymorphic problem as argument and returns a problem with additional partially instantiated formulae. A single iteration consists of a collection phase and an instantiation phase. Once the iterations are completed, a final step filters out all non-monomorphic formulae returned by the last iteration.

The initial phase of each iteration consists of computing two maps, \(M\) and \(P\), from the input problem~$\Phi$.
%
\begin{enumerate}
\item[\labelitemi] Given a symbol \(f\) occurring in \(\Phi\), the set \(M(f)\) consists of all tuples of monomorphic type arguments to which \(f\) is applied in \(\Phi\). For example, if \(\sym{foldl}\langle \ty{nat}, \ty{int}\rangle\) occurs in \(\Phi\), then \((\ty{nat}, \ty{int}) \in M(\sym{foldl}) \).

\item[\labelitemi] Given a formula \(\varphi \in \Phi\) and a symbol \(f\) occurring in \(\varphi\), the set \(P(\varphi, f)\) consists of all tuples of type arguments to which \(f\) is applied in \(\varphi\) and which contains a type variable. For example, if \(\sym{foldl}\langle \ty{nat}, \ty{list}(\alpha)\rangle\) occurs in \(\varphi\), then \((\ty{nat}, \ty{list}(\alpha)) \in P(\varphi, \sym{foldl}) \).
\end{enumerate}

These definitions depend on the precise form of the input formulae, which has been left undefined. It is important to parametrise \(P\) with \(\varphi\) because type variables are implicitly quantified at the formula level. The formula indicates the scope of type variables. This is not necessary for \(M\) since all the types it contains are monomorphic.

Once the maps \(M\) and \(P\) are initialised, each iteration performs the following steps to create new instances of formulae:

\begin{enumerate}

   \item Create an empty set of formulae \(\Phi'\).

   \item For each formula \(\varphi \in \Phi\) and for each symbol \(f\) occuring in \(\varphi\):
   \begin{enumerate}
    \item[2.1.] For each tuple \((\tau_1, \dots, \tau_n) \in  M(f)\)        and each tuple \((\upsilon_1, \dots, \upsilon_n) \in P(\varphi, f)\),
     for each \(i\), match \(\upsilon_i\) against \(\tau_i\), yielding the substitution \(\sigma_i\) in case of success.

    \item[2.2.] If all \(n\) matchings are successful and the substitutions \(\sigma_i\) are pairwise compatible,
add the formula \((\sigma_1 \circ \dots \circ \sigma_n)(\varphi)\) to \(\Phi'\).
   \end{enumerate}

   \item Return \(\Phi \cup \Phi'\).

\end{enumerate}

The algorithm is clearly sound because the newly generated formulae are instances of the initial problem's formulae, where type variables have been instantiated with monomorphic types. It is, however, not guaranteed to be complete.

\begin{example}Consider the following problem:
\begin{enumerate}
   \item \(\sym{p}\langle \ty{int}\rangle(0)\)
   \item \(\forall a: \alpha{,}\; \mathit{as}:\ty{list}(\alpha){,}\; \sym{p}\langle\alpha\rangle(a) \rightarrow \sym{p}\langle \ty{list}(\alpha)\rangle(\mathit{as})\)
\end{enumerate}
%
The first iteration matches \(\alpha\) against \(\ty{int}\) for $\sym{p}$, generating the formula
%
\begin{enumerate}
   \item[3.] \(\forall a: \ty{int}{,}\; \mathit{as}:\ty{list}(\ty{int}){,}\; \sym{p}\langle\ty{int}\rangle(a) \rightarrow \sym{p}\langle \ty{list}(\ty{int})\rangle(\mathit{as})\)
\end{enumerate}
%
The second iteration matches \(\alpha\) against \(\ty{list}(\ty{int})\), leading to the formula
%
\begin{enumerate}
   \item[4.] \(\forall a: \ty{list}(\ty{int}){,}\; \mathit{as}:\ty{list}(\ty{list}(\ty{int})){,}\; \sym{p}\langle\ty{list}(\ty{int})\rangle(a) \rightarrow \sym{p}\langle \ty{list}(\ty{list}(\ty{int}))\rangle(\mathit{as})\)
\end{enumerate}
%
Similarly the third iteration adds
%
\begin{enumerate}
   \item[5.] \(\forall a: \ty{list}(\ty{list}(\ty{int})){,}\; \mathit{as}:\ty{list}(\ty{list}(\ty{list}(\ty{int}))){,}\; \sym{p}\langle\ty{list}(\ty{list}(\ty{int}))\rangle(a) \rightarrow \sym{p}\langle \ty{list}(\ty{list}(\ty{list}(\ty{int})))\rangle(\mathit{as})\)
\end{enumerate}

\end{example}

This example illustrates how an infinite number of new formulae can be generated from a simple initial problem. Although the example may seem artificial [contrived?], similar problems frequently arise in practice. For example, the \sym{concat} function of Isabelle/HOL, which is characterised in the base case by the equation \(\sym{concat}\langle\alpha\rangle\; \sym{Nil}\langle\ty{list}(\alpha)\rangle = \sym{Nil}\langle\alpha\rangle\), exhibits the same behavior. Any reasonable implementation requires bounds limiting the number of new type arguments, substitutions and formulae to be useful.

% target page number: 2-4
\section{Low level algorithm}
\label{sec:low-level-algorithm}

The algorithm presented in the previous section is simple but too naive for an implementation. In this section, we present a lower level algorithm with the following features.
\begin{enumerate}
    \item[\labelitemi] Bounds are presented at several stages of the algorithm to curb potentially explosive enumerations.

    \item[\labelitemi] Type arguments are separated into old and new sets to avoid re-computing some of the same matchings in successive iterations.

    \item[\labelitemi] Substitutions are directly applied to the type arguments in $M$ and $P$ instead of the formulae. This dispenses from having to re-extract the type arguments from the formulae at each iteration. New formulae are only generated once all iterations are complete, in a separate, penultimate step.

    \item[\labelitemi] Once the new formulae are generated, their monomorphic types are mangled before the end result is output.
\end{enumerate}


These algorithms rely on ``primitives'' whose implementation depends on the specifics of the grammar and logic used. They will therefore not be expanded upon. The functions computing the following are assumed to exist:
\begin{enumerate}
   \item[\labelitemi] computing the initial type argument maps
   \item[\labelitemi] extracting type variables from a type tuple
   \item[\labelitemi] type matching
   \item[\labelitemi] substitution composition
   \item[\labelitemi] testing the compatibility of two substitutions
   \item[\labelitemi] returning the type variables instantiated by a substitution
   \item[\labelitemi] substitution application to formulae
\end{enumerate}

\SetKwFunction{IterMono}{iterative\_monomorphisation}
\begin{figure}
\begin{quote}
\begin{algorithm}[H]
\Fn(){\IterMono{\(\Phi\)}}{
   \SetKw{And}{and}\SetKw{True}{true}\SetKw{False}{false}\SetKw{To}{to}

   \SetKwData{Loop}{loop\_nb}\SetKwData{NewFormulae}{\(\Psi\)}
   \SetKwData{Problem}{\(\Phi\)}\SetKwData{AllSubst}{\(S^{\text{used}}\)}
   \SetKwData{Limit}{total\_new\_formulae}

   \SetKwFunction{Init}{initialisation}\SetKwFunction{FStep}{formula\_mono\_step}
   \SetKwFunction{TyVars}{type\_variables}\SetKwFunction{MonoSubst}{mono\_substs}

   \KwData{set of formulae \(\Phi\)}
   \KwResult{set of monomorphic formulae}

   \((M^{\text{old}}, P^{\text{old}}) \leftarrow (\emptyset, \emptyset)\)\;
   \((M^{\text{new}}, P^{\text{new}}) \leftarrow \Init{\Problem}\)\;

   \AllSubst\(\leftarrow \emptyset\)\;


   \For{\(i = 1\) \To \textcolor{ourblueviolet}{\Loop}}{
      \((M^{\text{next}}, P^{\text{next}})\leftarrow(\emptyset,\emptyset)\)\;
      \ForEach{\(\varphi \in \Problem\)} {
         \((M^{\Delta}, P^{\Delta}(\varphi), S^\Delta)\leftarrow \FStep(M^{\text{old}}, P^{\text{old}}(\varphi), M^{\text{new}}, P^{\text{new}}(\varphi))\)\;
         \(\AllSubst\leftarrow\AllSubst\cup S^\Delta\)\;
         \(M^{\text{next}}\leftarrow M^{\text{next}}\cup M^{\Delta}\)\;
         \(P^{\text{next}}(\varphi)\leftarrow P^{\text{next}}(\varphi)\cup P^{\Delta}(\varphi)\)\;
      }

      \((M^{\text{old}}, M^{\text{new}})\leftarrow (M^{\text{old}}\cup M^{\text{new}}, M^{\text{next}})\)\;
      \((P^{\text{old}}, P^{\text{new}})\leftarrow (P^{\text{old}}\cup P^{\text{new}}, P^{\text{next}})\)\;

   }

   \NewFormulae \(\leftarrow\emptyset\)\;
   \ForEach{\(\varphi\in\Phi\) polymorphic}{
      \(V\leftarrow \TyVars{\(\varphi\)}\)\;
      \(S^{\text{mono}}\leftarrow\MonoSubst{\AllSubst, \(\emptyset\), \(\{\}\), \(V\)}\)\;
      \ForEach{\(\sigma\in S^{\text{mono}}\)}{
         \textcolor{ourblueviolet}{
         \eIf{\(|\NewFormulae|<\Limit\)}{
            \textcolor{black}{
            \(\NewFormulae\leftarrow\NewFormulae\cup \{\sigma(\varphi)\}\)\;}
         }
         {\Return \NewFormulae}
      }}
   }
   \Return \NewFormulae\;

}
\end{algorithm}
\end{quote}
\caption{Pseudocode for iterative monomorphisation}
\label{iter_mono}
\end{figure}

The iterative monomorphisation algorithm, as implemented in Zipperposition, is described in \ref{iter_mono}. There are two main phases each consisting of a separate loop. The first loop applies a monomorphisation step to each formula for each iteration of the overall for loop until the user-set limit it reached. This bound is the only limit which is necessary for the algorithm to terminate. At the end of each iteration, the old and new maps are updated.
%Updating the maps progressively over the course of an iteration would be feasible but would result in an uneven treatment of formulae. Type arguments in a formula processed later could be matched against monomorphic type arguments generated at an earlier time in the same iteration. As a result, the later a formula is processed the more new type arguments it could generate.

Once all type arguments have been generated, the substitutions used to create those new type arguments are then combined in order to form monomorphising substitutions which are subsequently applied to the polymorphic formulae. There can be a high number of possible monomorphic formulae resulting from this process. This can be limited by setting a maximal number of new monomorphic formulae. In the Zipperposition implementation, this bound is one of the more important ones as the performance of the E prover can be significantly affected when it is given too many clauses.


\SetKwData{MonoCap}{mono\_cap}\SetKwData{MonoMult}{mono\_mult}\SetKwData{MonoFloor}{mono\_floor}
\SetKwData{PolyCap}{poly\_cap}\SetKwData{PolyMult}{poly\_mult}\SetKwData{PolyFloor}{poly\_floor}
\begin{figure}
\begin{quote}
\begin{algorithm}[H]
   
   %\LinesNumbered
   \SetKwFunction{SubstGen}{subst\_generation}\SetKwFunction{TyVars}{type\_variables}
   \SetKwFunction{FMonoStep}{formula\_mono\_step}

   \Fn(){\FMonoStep{\(M^{\text{old}}, M^{\text{new}}, P^{\text{old}}(\varphi), P^{\text{new}}(\varphi)\)}}{
   \SetKwData{Subst}{substs}\SetKwData{TypeVars}{type\_variables}
   \SetKwData{MaxMono}{max\_mono\_args}
   \SetKwData{MaxPoly}{max\_poly\_args}
   \SetKwData{UsedSubst}{\(S^{\text{used}}\)}

   \SetKw{And}{and}\SetKw{True}{true}\SetKw{False}{false}\SetKw{Stop}{stop}

   \SetKwFunction{Max}{max}\SetKwFunction{Min}{min}
   \SetKwFunction{Domain}{subst\_domain}\SetKwFunction{Len}{len}

   \KwData{
      \hspace{-2.7em}\begin{minipage}[t]{.8\textwidth}
      \begin{enumerate}
         \item[] old and new monomorphic type argument maps \(M^{\text{old}}, M^{\text{new}}\)
         \item[] old and new non-monomorphic type argument maps \(P^{\text{old}}(\varphi), P^{\text{new}}(\varphi)\)
      \end{enumerate}
      \end{minipage}
   }
   \KwResult{
      \hspace{-2.7em}\begin{minipage}[t]{.8\textwidth}
      \begin{enumerate}
         \item[] monomorphic type argument map
         \item[] non-monomorphic type argument map
         \item[] set of substitutions
      \end{enumerate}
      \end{minipage}
   }
   \BlankLine

   \Subst \(\leftarrow\) \SubstGen{\(M^{\text{new}}\), \(P^{\text{new}}(\varphi)\)}\;
   \Subst \(\leftarrow\) \Subst \(\cup\) \SubstGen{\(M^{\text{new}}\), \(P(\varphi)\)}\;
   \Subst \(\leftarrow\) \Subst \(\cup\) \SubstGen{\(M\), \(P^{\text{new}}(\varphi)\)}\;
   \BlankLine

   \TypeVars \(\leftarrow\) \TyVars{\(\varphi\)}\;

   \textcolor{ourblueviolet}{
   \MaxMono \(\leftarrow\) \Max{\Min{\MonoFloor, \(|M\cup M^{\text{new}}| \cdot \)\MonoMult}, \MonoCap}\;
   \MaxPoly \(\leftarrow\) \Max{\Min{\PolyFloor, \(|P(\varphi)\cup P^{\text{new}}(\varphi)| \cdot \)\PolyMult}, \PolyCap}\;
   }

   \BlankLine

   \UsedSubst \(\leftarrow\emptyset\)\;
   \ForEach{\(\sigma\in \Subst\)}{
      \ForEach{\(f\mapsto (\upsilon_1, \dots,\upsilon_n)\in P(\varphi)\)}{
            \eIf{\TyVars{\((\upsilon_1, \dots, \upsilon_n)\)} \(\subseteq\) \Domain{\(\sigma\)}}{
               \textcolor{ourblueviolet}{
               \uIf{\(|M^{\text{next}}| < \MaxMono\) \label{algo:relative_bound}}{
                  \textcolor{black}{
                  \(M^{\text{next}}(f)\leftarrow M^{\text{next}}(f)\cup\{(\sigma(\upsilon_1),\dots,\sigma(\upsilon_n))\}\)\;
                  \UsedSubst \(\leftarrow \UsedSubst \cup\{\sigma\}\)\;}
               }
               \uElseIf{\(|P^{\text{next}}(\varphi)| \geq \MaxPoly\) }{
                  blablabliblou\;
                  \(M^\text{next} \leftarrow M^{\text{next}}\setminus (M^\text{old} \cup M^\text{new})\)\;
                  \(P^\text{next}(\varphi)\leftarrow P^{\text{next}}(\varphi)\setminus (P^\text{old}(\varphi)\cup P^\text{new}(\varphi))\)\;
                  \Return \((M^\text{next}, P^\text{next}(\varphi), \UsedSubst)\)
               }}
            }
            {
               \textcolor{ourblueviolet}{
               \If{\(|P^{\text{next}}(\varphi)| < \MaxPoly\)\label{algo:ref_2}} {
               \textcolor{black}{
               \(P^{\text{next}}(\varphi)(f)\leftarrow P^{\text{next}}(\varphi)(f)\cup\{(\sigma(\upsilon_1),\dots,\sigma(\upsilon_n))\}\)\;
               \UsedSubst \(\leftarrow \UsedSubst \cup\{\sigma\}\)\;
            }}
            }

         }
      }
   }
   \BlankLine

   \Return \((M^{\text{next}}\setminus (M^\text{old} \cup M^\text{new}), P^{\text{next}}(\varphi)\setminus (P^\text{old}(\varphi)\cup P^\text{new}(\varphi)), \UsedSubst)\)
}

\end{algorithm}
\end{quote}
\caption{Formula Monomorphisation Step}
\label{mono_step}
\end{figure}

Function \ref{mono_step} computes new type arguments for a single formula. The separation of the type arguments into ``old'' and ``new'' maps is exploited here. Pairs of type argument tuples must contain at least one new type argument in order to be matched and generate a substitution. This avoids computing matchings that have already been made in previous iterations. Unfortunately, not all such redundant computations can be avoided because different matchings with entirely different types can yield the same substitution. Furthermore, 

The limits on the number of new type monomorphic arguments has three components (similar bounds are used for the non-monomorphic):
\begin{enumerate}
   \item \MonoCap is an absolute limit on the total number of new type arguments
   \item \MonoMult is used to allow the total number of type arguments to increase by a certain proportion
   \item \MonoFloor balances out \MonoMult when the number of type arguments is too low, and guarantees that a minimum number of new type arguments
\end{enumerate}

At line \ref{algo:relative_bound} (and similarly at line \ref{algo:ref_2}), adding conditions dependent on the size of \(M^{\text{next}}(f)\) (respectively \(P^{\text{next}}(\varphi)(f)\)), would create finer grained bounds. This may be useful if some function symbols have too many type arguments and prevent new type arguments of other function symbols from being generated. Adding a cap on the number of new type arguments per function symbol may help in smoothing out the distribution of new type arguments over function symbols.


\begin{figure}
\begin{quote}
\begin{algorithm}[H]
\SetKwFunction{SubstGen}{substitution\_generation}
\Fn(){\SubstGen{\(M, P(\varphi)\)}}{
%   \caption{Substitution Generation()}
%   \SetAlgoNoLine
%   \LinesNumbered
   \SetKw{And}{and}\SetKw{True}{true}\SetKw{False}{false}\SetKw{Stop}{stop}
   \SetKwData{SubstLimit}{substitution\_limit}
   \SetKwFunction{Success}{Success}\SetKwFunction{Compatible}{compatible}
   \SetKwFunction{Match}{match}
   \SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
   \SetKw{Break}{break}

   \KwData{%
      \hspace{-2.7em}\begin{minipage}[t]{.8\textwidth}
      \begin{enumerate}
         \item[] monomorphic type argument map \(M\)
         \item[] non-monomorphic type argument map \(P(\varphi)\)
      \end{enumerate}
      \end{minipage}
   }
   \KwResult{set of substitutions}
   \BlankLine

   \(S\leftarrow \emptyset\)\;
   \ForEach{\(f\mapsto (\upsilon_1, \dots,\upsilon_n)\in P(\varphi)\)}{
      \ForEach{\( (\tau_1, \dots,\tau_n) \in M(f) \)}{
         \(\sigma\leftarrow \{\}\)\;
         \(i \leftarrow 1\)\;
         \While{\(i \leq n\)}{
            \eIf{\(\Match{\(\upsilon_i\), \(\tau_i\)}\) has the form \Success{\(\sigma_i\)} \And \Compatible{\(\sigma\), \(\sigma_i\)}}{
               \(\sigma\leftarrow\sigma_i\circ\sigma\)
            }
            {\Break}

            \(i\leftarrow i+1\)\;
         }
         
         \If{\(i > n\)}{
            \textcolor{ourblueviolet}{
               \eIf{\(|S| < \SubstLimit\)}{
                  \textcolor{black}{\(S\leftarrow S\cup \{\sigma\}\)\;}
               }
               {\Return \(S\)}
            }
         }
      }

   }
   \Return \(S\)\;

}
\end{algorithm}
\end{quote}
\caption{Pseudocode for substitution generation}
\end{figure}

This function computes all possible matchings between the type arguments of the given type argument maps and returns the resulting substitutions. For each pair of type argument tuples, the non-monomrophic types are matched against their monomorphic counterparts and the resulting substitutions are composed if they are compatible. If the substitutions are incompatible, the matchings are discarded. [Note that the composition of two compatible substitutions is commutative].

Adding a limit to the number of substitutions generated may be necessary if substitution generation becomes a bottleneck. In this case, it is a simple matter of stopping the function and returning \(S\) once a certain limit is reached.
\begin{figure}
\begin{quote}
   \begin{algorithm}[H]

   
   \SetKwFunction{MonoSubst}{mono\_substs}
   \SetKwFunction{Domain}{domain}
   \SetKwData{Limit}{subst\_limit}
   \SetKw{And}{and}\SetKw{True}{true}\SetKw{False}{false}\SetKw{Stop}{stop}
   \SetKw{Let}{let}
   \SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

   \Fn(){\MonoSubst{\(S^{\text{used}}, S^\text{acc}, \sigma^\text{acc}, V\)}}{

   \KwData{%
      \hspace{-2.7em}\begin{minipage}[t]{.8\textwidth}
      \begin{enumerate}
         \item[] set of substitutions \(S^{\text{used}}\) and \(S^\text{acc}\)
         \item[] single substitution \(\sigma^\text{acc}\)
         \item[] set of type variables \(V\)
      \end{enumerate}
      \end{minipage}
   }

   \KwResult{set of substitutions}
   \BlankLine

   \eIf{\(V = \emptyset\)}{
    \Return \(S^\text{acc}\cup\{\sigma^\text{acc}\}\)\;%}
   }
   {
      \Let \(\alpha \) such that \(\alpha\in V\)\;
      \ForEach{\(\sigma^\text{next}\in S^{\text{used}}\) such that, \(\alpha\in\Domain{\(\sigma^\text{next}\)}\) \And \(\sigma^\text{acc}\) compatible with \(\sigma^\text{next}\)}{
         \textcolor{ourblueviolet}{
         \eIf{\(|S^\text{acc}|<\Limit\)}{
            \textcolor{black}{
            \(S^\text{acc}\leftarrow \MonoSubst{\(S^{\text{used}}, S^\text{acc}, \sigma^\text{next}\circ\sigma^\text{acc}, V\setminus\Domain{\(\sigma^\text{next}\)}\)}\)\;}
         }
         {\Return \(S^\text{acc}\)}}
      }
      \Return \(S^\text{acc}\)\;
   }
   }


\end{algorithm}
\end{quote}
\caption{Monomorphising Substitutions}
\end{figure}

This recursive function computes all substitutions that can instantiate a set of type variables. The substitutions are obtained by composition of compatible substitutions from a given set. The returned substitutions are said to be ``monomorphising'' with regards to the set of input type variables \(V\) because they instantiate all type variables in \(V\). In the Zipperposition implementation this limit was one of the most important bounds because the total number of possible monomorphising substitutions is very high but very few are necessary in practice.

In the Zipperposition implementation, due the substitutions in \(U\) being selected on the basis on which type variable they instantiate, all substitutions are kept in a map which makes this selection faster.

Because this function often hits the substitution limit, the order of substitutions in \(U\) (or the map in Zipperposition) can have a significant impact on the resulting monomorphising substitutions. This may be a relevant heuristic to tweak depending on the input problem.


% target page number: 2-4
\section{Evaluation}
\label{sec:evaluation}

% Provide complete list of problems explain which ones were excluded and why
% We ignore the following bounds: ty var limit per clause, subst per ty var, limiting the new type args per clause

\subsection{Parameter optimisation}

Considering the total number of parameters, it would be impractical to exhaustively test all option combinations. Consequently, options have been grouped together into sets of 2 or 3 options that will be more thouroughly tested. Two options will be part of the same group if it is deemed likely that a change in one of the options will significantly impact how much a change in the second option will affect the overall results.

The first two groups of options are natural as they affect how many new monomorphic and polymorphic type arguments are generated respectively for each symbol at each iteration. These options are closely linked and must be set together if they are to be relevant.

During an iteration, for each symbol (for each clause in the polymorphic case), the number of newly generated type arguments is determined by this formula:
\( \min(\text{cap}, \max(\text{floor}, \text{multiplier} \cdot \text{number of type arguments})) \)

The multiplier allows for a controlled increase of the number of type arguments, relative to the size of the problem whilst the floor prevents some symbols seeing no new type arguments if the multiplier is too low.
The cap acts as a final limit in the case the explosion is too fast despite the multiplier bound.

\begin{table}[th]
\caption{Evaluation of bounds for monomorphic type argument generation}
\centering\begin{tabular}{@{}l*{9}{>{\centering\arraybackslash}p{1.1em}}@{}}
   \toprule
   & &&& \multicolumn{3}{c}{floor} \\
   & \multicolumn{3}{c}{1} & \multicolumn{3}{c}{3} & \multicolumn{3}{c}{9}\\
   \cmidrule(l){2-10}
   & &&& \multicolumn{3}{c}{multiplier} \\
   \multirow{1}{2em}{cap} & 0 & 1 & 2 & 0 & 1 & 2 & 0 & 1 & 2\\
    \cmidrule(lr){2-4} \cmidrule(lr){5-7} \cmidrule(l){8-10}
    25   & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    50   & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    100  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    \(\infty\) & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    \bottomrule
\end{tabular}
\end{table}

\bigskip
\bigskip

If the floor and multiplier are set to 0 and 0, no new polymorphic type arguments will be generated, as a result the cap will be irrelevant.

\begin{table}[th]
\caption{Evaluation of bounds for polymorphic type argument generation}
\centering\begin{tabular}{@{}l*{9}{>{\centering\arraybackslash}p{1.1em}}@{}}
   \toprule
   & &&& \multicolumn{3}{c}{floor} \\
   & \multicolumn{3}{c}{0} & \multicolumn{3}{c}{3} & \multicolumn{3}{c}{6}\\
   \cmidrule(l){2-10}
   & &&& \multicolumn{3}{c}{multiplier} \\
    \multirow{1}{2em}{cap} & 0 & 0.5 & 1 & 0 & 0.5 & 1 & 0 & 0.5 & 1 \\
    \cmidrule(lr){2-4} \cmidrule(lr){5-7} \cmidrule(l){8-10}
    10 &   & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    20 &   & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    40 &   & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    \(\infty\) & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    \bottomrule
\end{tabular}
\end{table}

\begin{table}[th]
\caption{Evaluation of bounds for substitution generation}
\centering\begin{tabular}{@{}l*{4}{>{\centering\arraybackslash}p{1em}}@{}}
   \toprule
   & \multicolumn{4}{c}{mono subst}\\
   \multirow{1}{4em}{subst cap} & 2 & 5 & 7 & 10\\
   \midrule
   50   & 0 & 0 & 0 & 0\\
   100  & 0 & 0 & 0 & 0\\
   500  & 0 & 0 & 0 & 0\\
   \(\infty\) & 0 & 0 & 0 & 0\\
   
   \bottomrule
\end{tabular}
\end{table}

This table groups two bounds that directly affect the number of clauses generated, a first one that allows at most a number of new clauses equal to `multiplier' times the original number of clauses. And the cap that gives an absolute bound over the total number of clauses generated.

The choice to also include e-timeout in this table is due to the fact that E being successful in solving a monomorphised problem in a certain time limit has been observed to be highly dependent on the number of clauses it is given.

\begin{table}[th]
\caption{Evaluation of bounds directly related to the size of the output problem}
\centering\begin{tabular}{@{}l*{9}{>{\centering\arraybackslash}p{1.1em}}@{}}
   \toprule
   & &&& \multicolumn{3}{c}{cap} \\
   & \multicolumn{3}{c}{500} & \multicolumn{3}{c}{2000} & \multicolumn{3}{c}{\(\infty\)}\\
   \cmidrule(l){2-10}
   & &&& \multicolumn{3}{c}{multiplier} \\
    \multirow{1}{5.4em}{E timeout (s)} & 1 & 2 & 3 & 1 & 2 & 3 & 1 & 2 & 3 \\
    \cmidrule(lr){2-4} \cmidrule(lr){5-7} \cmidrule(l){8-10}
    2   & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    5   & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    10  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    \(\infty\)& 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    \bottomrule
\end{tabular}
\end{table}
The next table gathers the bounds linked to substitutions generation, the first one limits the number of monomorphising substitutions that are generated per clause during the final phase. The second one gives an absolute cap on the overall number of substitutions generated at each clause during the type argument generation.


This last table attempts to determine which are the best bounds related to the depth at which the monomorphisation problem is run as well as how long zipperposition is allowed to run before monomorphisation (and the subsequent call of E) is ran.

\begin{table}[th]
% not super happy with caption
\caption{Evaluation of parameters indirectly related to the size of the output problem}
\centering\begin{tabular}{@{}l*{4}{>{\centering\arraybackslash}p{1em}}@{}}
   \toprule
   & \multicolumn{4}{c}{loop nb} \\
   \multirow{1}{4.5em}{E call step} & 2 & 3 & 4 & 5\\
   \midrule
   0 & 0 & 0 & 0 & 0\\
   15 & 0 & 0 & 0 & 0\\
   45 & 0 & 0 & 0 & 0\\
   90 & 0 & 0 & 0 & 0\\
   
   \bottomrule
\end{tabular}
\end{table}



\subsection{Monomorphisation as preprocessor}

\begin{table}[ht]
\caption{Evaluation of native polymorphism vs.\ monomorphisation}
\centering\begin{tabular}{@{}lccc@{}}
   \toprule
   & Native & Mono & Union \\
   \midrule
   E  &   & 0 & 0 \\
   Leo-III & 0 & 0 & 0 \\
   Satallax &  & 0 & 0 \\
   Vampire & 0 & 0 & 0 \\
   Zipperposition & 0 & 0 & 0 \\[1.5\jot]
   Total & 0 & 0 & 0 \\
   \bottomrule
\end{tabular}
\end{table}

\subsection{E as Zipperposition backend}

\begin{table}[ht]
\caption{Evaluation of Zipperposition without E vs. with E}
\centering\begin{tabular}{@{}lccc@{}}
   \toprule
   & without E & with E & Union \\
   \midrule
   Zipperposition & 0 & 0 & 0 \\
   \bottomrule
\end{tabular}
\end{table}

\break

% target page number: 0.5-1
\section{Related work}
\label{sec:related-work}

  * explicitly quantified formulas a la TPTP, existentials, how to eliminate

  * Böhme
  * similar algo implemented in Why3?

% target page number: 0.5-1
\section{Conclusion}
\label{sec:conclusion}

% summary 

% Future avenues

\section*{Acknowledgements}

* Sascha Böhme

\bibliography{citations}

\end{document}
