\documentclass{article}

\usepackage{soul}

\setlength{\parindent}{0pt}

\begin{document}

TODO:
    \begin{itemize}
       \item \st{contact Sascha Boehme about authorship}
        \item are there any implementation of this (or comparable) algorithm in that have been evaluated?
        \item finish implementation (mostly there)
        \item test and evaluate implementation (well on the way)
        \item (can wait) merge implementation (review code with active contributor(s) beforehand)
        \item find pretty inline setup for pseudo code
        \item (in order) write high/low level algo
        \item write implementation and evaluation
        \item write background
        \item write related work
        \item write conclusion
        \item write intro
        \item reread, spellcheck ...
    \end{itemize}

% target page number: 2-2.5
\section{Introduction}
\begin{itemize}
    \item context and motivation (automatic theorem proving, better performance)
       Automatic theorem provers have many applications, and are particularly useful in assisting in the elaboration of formal proofs. Speed is one of the main limitations of the use of theorem provers in this application. For instance, when used as a backend to a proof assistant a prover can often be expected to run for no more than a few seconds for a given instance of a problem.
    \item what we are trying to do (monomorphisation)
       This paper presents a method, first introduced in [sacha's thesis] [as far as i know], that allows for higher order polymorphic problems to be approximated monomorphically. This algorithm aims to acheive the following:
         \begin{itemize}
            \item allow for existing higher order monomorphic theorem provers to be extended [albeit very crudely] to higher order polymorphic languages
            \item improve the performance of existing higher order polymorphic theorem provers
         \end{itemize}

         It is therefore aimed at being practically useful, as a result it is not complete [ref to example in the paper where we explain that?]. 

    \item basic idea of the algorithm 
    \item overview of the paper
\end{itemize}

% target page number: 0.5-1.5
\section{Background}

\begin{itemize}
    \item Language, TF1 (might be TH1 or something else)
\end{itemize}

% target page number: 2-4
\section{High level algorithm}

We consider a problem \(P\) to be a set of clauses \(C_1, \dots, C_n\).

Algorithm :
\begin{itemize}
    \item Let \(F\) be the set of all function symbols in \(P\).
    \item We consider \(M\) a map from the function symbols of \(F\) to the set of monomorphic type arguments with which the function symbol is instantiated \(P\) [unclear]

    For instance if \(f^{a \rightarrow b}\) occurs in \(P\) (with \(a\) and \(b\) monomorphic types) then, \(a \rightarrow b \in M(f) \).
    \item We consider \(P\) a map from the function symbols of \(F\) to the set of non-monomorphic type arguments with which the function symbol is instantiated in \(P\). [still somewhat unclear] This map is additionally paramatrised by the clause in which the function symbol is instantiated.

    This is important because type arguments are quantified at the clause level. 
\end{itemize}

% target page number: 2-4
\section{Low level algorithm}

Precise algo description (pseudo code). Explicit loops, and bounds.

% target page number: 2-4
\section{Implementation and evaluation}

Introduce context of zipperposition (do it in intro or background?).

Explain how the final bounds were chosen (i liked the way those numbers looked)

Present evaluation method (which problems were used, options used, server characteristics ect...)

Compare the following:
    \begin{itemize}
        \item no call to e (no monomorphisation)
        \item call e on start no monomorphisation
        \item call e (default) no monomorphisation
        \item call e on start monomorphisation
        \item call e (default) monomorphisation
        \item maybe compare a few different bounding heuristics?
    \end{itemize}

Compare performance with implementation of a similar algorithm (if any).

Maybe compare with implementation of other kinds of monomorphisation algorithms (if appropriate).

% target page number: 0.5-1
\section{Related work}

\begin{itemize}
    \item that part of Sascha Boehme's thesis (Proving Theorems of Higher-Order Logic with SMT Solvers)
    \item How to Encode Polymorphic Types Safely and EfÔ¨Åciently
    \item Encoding Monomorphic and Polymorphic Types
\end{itemize}

% target page number: 0.5-1
\section{Conclusion}

\end{document}
